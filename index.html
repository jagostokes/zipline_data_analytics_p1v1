<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SF Zipline Simulation</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* Map container - takes full space with dark blue background */
        #map {
            flex: 1;
            height: 100vh;
            background: #0a1929; /* Dark blue background */
        }

        /* Floating control buttons - positioned at top left of sidebar */
        #floating-controls {
            position: fixed;
            right: 340px;
            top: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #floating-controls button {
            width: 80px;
            padding: 12px 0;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        /* Floating Stats Box (Left Side) */
        #floating-stats {
            position: fixed;
            left: 20px;
            top: 20px;
            z-index: 1000;
            width: 280px;
        }

        /* Right panel - Dark theme */
        #panel {
            width: 340px;
            height: 100vh;
            background: #0d1b2a;
            border-left: 2px solid #1b263b;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        /* Panel header - Dark theme */
        .panel-header {
            padding: 14px 18px;
            background: #1b263b;
            color: #ffffff;
            border-bottom: 2px solid #415a77;
        }

        .panel-header h1 {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 2px;
            letter-spacing: 0.5px;
        }

        .panel-header p {
            font-size: 11px;
            color: #778da9;
        }

        /* Panel content - Compact dark theme */
        .panel-content {
            flex: 1;
            padding: 12px 16px;
        }

        /* Section styling - Compact */
        .section {
            margin-bottom: 16px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: #778da9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #1b263b;
        }

        /* Control group - Compact dark theme */
        .control {
            margin-bottom: 12px;
        }

        .control label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: 500;
            color: #e0e1dd;
            margin-bottom: 5px;
        }

        .control .value {
            font-weight: 600;
            color: #4cc9f0;
        }

        .control input[type="range"] {
            width: 100%;
            height: 5px;
            border-radius: 3px;
            background: #1b263b;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4cc9f0;
            cursor: pointer;
        }

        .control input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4cc9f0;
            cursor: pointer;
            border: none;
        }

        .control input[type="number"] {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #1b263b;
            border-radius: 4px;
            font-size: 12px;
            background: #1b263b;
            color: #e0e1dd;
        }

        .control input[type="number"]:focus {
            outline: none;
            border-color: #4cc9f0;
            box-shadow: 0 0 0 2px rgba(76, 201, 240, 0.2);
        }

        .control small {
            display: block;
            font-size: 10px;
            color: #778da9;
            margin-top: 3px;
        }

        /* Buttons */
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 20px;
        }

        .button-group.single {
            grid-template-columns: 1fr;
        }

        button {
            padding: 8px 14px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #floating-controls #start-btn {
            background: linear-gradient(135deg, #06d6a0 0%, #05b085 100%);
            color: #ffffff;
            border: 2px solid #06d6a0;
        }

        #floating-controls #start-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #05b085 0%, #048869 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(6, 214, 160, 0.4);
        }

        #floating-controls #stop-btn {
            background: linear-gradient(135deg, #ef476f 0%, #d6315c 100%);
            color: #ffffff;
            border: 2px solid #ef476f;
        }

        #floating-controls #stop-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #d6315c 0%, #b82549 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(239, 71, 111, 0.4);
        }

        #floating-controls #start-btn:disabled,
        #floating-controls #stop-btn:disabled,
        #floating-controls #reset-btn:disabled {
            opacity: 0.4;
            transform: none;
            cursor: not-allowed;
        }

        #floating-controls #reset-btn {
            background: linear-gradient(135deg, #ffd60a 0%, #e6c200 100%);
            color: #000000;
            border: 2px solid #ffd60a;
        }

        #floating-controls #reset-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #e6c200 0%, #ccac00 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(255, 214, 10, 0.4);
        }

        #find-n-btn {
            background: #17a2b8;
            color: white;
            grid-column: 1 / -1;
            margin-top: 8px;
        }

        #find-n-btn:hover:not(:disabled) {
            background: #138496;
        }

        #demo-preset-btn {
            background: #6f42c1;
            color: white;
            grid-column: 1 / -1;
        }

        #demo-preset-btn:hover:not(:disabled) {
            background: #5a32a3;
        }

        #load-districts-btn {
            background: #17a2b8;
            color: white;
            grid-column: 1 / -1;
        }

        #load-districts-btn:hover:not(:disabled) {
            background: #138496;
        }

        /* Performance Metrics - Professional Dashboard */
        .stats {
            background: linear-gradient(135deg, #1b263b 0%, #0d1b2a 100%);
            border: 1px solid #415a77;
            border-radius: 8px;
            padding: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .stats-header {
            background: #415a77;
            padding: 10px 12px;
            border-bottom: 2px solid #4cc9f0;
        }

        .stats-header h3 {
            margin: 0;
            font-size: 13px;
            font-weight: 700;
            color: #e0e1dd;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stats-body {
            padding: 10px 12px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 7px 0;
            border-bottom: 1px solid rgba(65, 90, 119, 0.3);
        }

        .stat-row:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }

        .stat-label {
            font-size: 11px;
            color: #778da9;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .stat-value {
            font-size: 15px;
            font-weight: 700;
            color: #4cc9f0;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 8px rgba(76, 201, 240, 0.3);
        }

        /* Status badge - Dark theme */
        .status-badge {
            display: inline-block;
            padding: 3px 9px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-idle {
            background: #415a77;
            color: #e0e1dd;
        }

        .status-running {
            background: #06d6a0;
            color: #0d1b2a;
        }

        .status-paused {
            background: #ffd60a;
            color: #0d1b2a;
        }

        /* Drone marker styling */
        .drone-marker {
            background: transparent !important;
            border: none !important;
        }

        .drone-icon {
            font-size: 20px;
            color: #ffffff;  /* White drones for dark theme */
            text-shadow: 0 0 4px #00ff00, 0 0 8px #00ff00;  /* Green glow */
            font-weight: bold;
            transform-origin: center center;
            transition: transform 0.1s linear;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
        }

        /* Responsive */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #map {
                height: 50vh;
            }

            #panel {
                width: 100%;
                height: 50vh;
                border-left: none;
                border-top: 2px solid #dee2e6;
            }
        }
    </style>
</head>
<body>
    <!-- Map container -->
    <div id="map"></div>

    <!-- Floating Control Buttons -->
    <div id="floating-controls">
        <button id="start-btn">▶ START</button>
        <button id="stop-btn" disabled>■ STOP</button>
        <button id="reset-btn">⟲ RESET</button>
    </div>

    <!-- Floating Stats Box (Left Side) -->
    <div id="floating-stats">
        <div class="stats">
            <div class="stats-header">
                <h3>⚡ Live Performance Metrics</h3>
            </div>
            <div class="stats-body">
                <div class="stat-row">
                    <span class="stat-label">Avg Delivery</span>
                    <span class="stat-value" id="avg-delivery-stat">--</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">P95 Wait</span>
                    <span class="stat-value" id="p95-wait-stat">--</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Completed</span>
                    <span class="stat-value" id="completed-stat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Queue Size</span>
                    <span class="stat-value" id="queue-stat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Active Drones</span>
                    <span class="stat-value" id="active-drones-stat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Total Orders</span>
                    <span class="stat-value" id="total-orders-stat">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Rate (Actual)</span>
                    <span class="stat-value" id="actual-rate-stat">--</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Sim Time</span>
                    <span class="stat-value" id="sim-time-stat">0:00:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Real Time</span>
                    <span class="stat-value" id="real-time-stat">0:00:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Speed</span>
                    <span class="stat-value" id="speed-stat">1.0x</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Control panel -->
    <div id="panel">
        <div class="panel-header">
            <h1>SF Zipline Simulation</h1>
            <p>Discrete-event drone delivery simulation</p>
        </div>

        <div class="panel-content">
            <!-- Demo Preset -->
            <div class="section">
                <button id="demo-preset-btn">Load Demo Preset</button>
                <button id="load-districts-btn" style="margin-top: 10px;">Load SF Residential Districts (5 Areas)</button>
            </div>

            <!-- Environment Parameters -->
            <div class="section">
                <div class="section-title">Environment</div>

                <div class="control">
                    <label>
                        <span>Delivery Radius</span>
                        <span class="value" id="radius-value">2.0 km</span>
                    </label>
                    <input type="range" id="radius-slider" min="0.5" max="10" step="0.5" value="2.0">
                    <small>Area for uniform order distribution</small>
                </div>

                <div class="control">
                    <label>
                        <span>Buildings Radius</span>
                        <span class="value" id="buildings-radius-value">3.0 km</span>
                    </label>
                    <input type="range" id="buildings-radius-slider" min="0.5" max="10" step="0.5" value="3.0">
                    <small>OSM building footprint fetch radius</small>
                </div>
            </div>

            <!-- Fleet Parameters -->
            <div class="section">
                <div class="section-title">Fleet</div>

                <div class="control">
                    <label>
                        <span>Number of Drones</span>
                        <span class="value" id="num-drones-value">10</span>
                    </label>
                    <input type="range" id="num-drones-slider" min="1" max="1000" step="5" value="10">
                </div>

                <div class="control">
                    <label for="speed-input">Drone Speed (km/h)</label>
                    <input type="number" id="speed-input" min="30" max="120" step="5" value="70">
                    <small>Cruise speed (70 km/h ≈ 43 mph)</small>
                </div>
            </div>

            <!-- Timing Constants -->
            <div class="section">
                <div class="section-title">Timing</div>

                <div class="control">
                    <label for="load-time-input">Load Time (sec)</label>
                    <input type="number" id="load-time-input" min="10" max="120" step="5" value="30">
                    <small>Package loading at hub</small>
                </div>

                <div class="control">
                    <label for="service-time-input">Service Time (sec)</label>
                    <input type="number" id="service-time-input" min="10" max="300" step="10" value="30">
                    <small>Time at delivery location</small>
                </div>

                <div class="control">
                    <label for="turnaround-time-input">Turnaround Time (sec)</label>
                    <input type="number" id="turnaround-time-input" min="10" max="300" step="10" value="60">
                    <small>Reload/recharge at hub</small>
                </div>
            </div>

            <!-- Demand Parameters -->
            <div class="section">
                <div class="section-title">Demand</div>

                <div class="control">
                    <label>
                        <span>Orders per Hour</span>
                        <span class="value" id="orders-per-hour-value">60</span>
                    </label>
                    <input type="range" id="orders-per-hour-slider" min="5" max="1000" step="10" value="60">
                </div>

                <div class="control">
                    <label>
                        <span>Time Scale</span>
                        <span class="value" id="time-scale-value">1.0x</span>
                    </label>
                    <input type="range" id="time-scale-slider" min="0.1" max="50" step="0.5" value="1.0">
                    <small>Simulation speed multiplier</small>
                </div>
            </div>

            <!-- Fleet Optimizer Section -->
            <div class="section">
                <h3>Fleet Optimizer</h3>
                <div class="control">
                    <label>
                        <span>Target P95 Wait (minutes)</span>
                        <span class="value" id="target-p95-value">5</span>
                    </label>
                    <input type="range" id="target-p95-slider" min="1" max="20" step="1" value="5">
                    <small>SLA target for 95th percentile wait time</small>
                </div>
                <div class="control">
                    <label>
                        <span>Simulation Horizon (hours)</span>
                        <span class="value" id="horizon-value">3</span>
                    </label>
                    <input type="range" id="horizon-slider" min="1" max="6" step="1" value="3">
                    <small>Simulated time for optimization</small>
                </div>
                <button id="find-n-btn">Find Minimum Fleet Size</button>
                <div id="optimizer-status" style="margin-top: 10px; font-size: 13px; color: #495057;"></div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- osmtogeojson -->
    <script src="https://unpkg.com/osmtogeojson@2.2.12/osmtogeojson.js"></script>

    <!-- Application script -->
    <script>
        // =============================================================================
        // Constants
        // =============================================================================

        const HUB_LAT = 37.7749;
        const HUB_LNG = -122.4194;

        // Aliases for consistency (used throughout simulation code)
        const hubLat = HUB_LAT;
        const hubLng = HUB_LNG;

        // =============================================================================
        // Leaflet Map Initialization
        // =============================================================================

        console.log('Zipline Drone Logistics Simulator loaded');
        console.log('Leaflet version:', L.version);
        console.log('osmtogeojson available:', typeof osmtogeojson !== 'undefined');

        // Initialize map centered on SF districts (zoomed out to show all residential areas)
        const map = L.map('map', {
            zoomControl: false,           // Remove +/- zoom controls
            attributionControl: true
        }).setView([37.755, -122.445], 12); // Center on mid-SF, zoom to show Richmond/Sunset/Bayview

        // Dark theme tile layer (CartoDB Dark Matter)
        // L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        //     attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        //     subdomains: 'abcd',
        //     maxZoom: 20,
        //     minZoom: 10
        // }).addTo(map);

        // Alternative: For solid dark blue background, comment out above and uncomment below
        // (No map tiles, just dark blue)
        // map.options.zoomControl = false; // Optional: hide zoom controls for cleaner look

        // Create layer groups
        const buildingsLayer = L.layerGroup().addTo(map);
        const ordersLayer = L.layerGroup().addTo(map);
        const dronesLayer = L.layerGroup().addTo(map);

        // Create hub marker (fixed location) - glowing for dark theme
        const hubIcon = L.divIcon({
            className: 'hub-marker',
            html: '<div style="background: #ffd700; width: 20px; height: 20px; border-radius: 50%; border: 3px solid #ffffff; box-shadow: 0 0 12px #ffd700, 0 0 20px #ffd700, 0 0 30px #ffd700;"></div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        const hubMarker = L.marker([HUB_LAT, HUB_LNG], {
            icon: hubIcon,
            title: 'Drone Hub',
            zIndexOffset: 1000
        }).addTo(map);

        // Add popup to hub marker
        hubMarker.bindPopup('<b>Drone Hub</b><br>San Francisco, CA<br>All drones operate from here');

        console.log('Map initialized at SF:', HUB_LAT, HUB_LNG);
        console.log('Layer groups created: buildings, orders, drones');

        // =============================================================================
        // Building Footprints (Overpass API)
        // =============================================================================

        let buildingsCache = null;
        let lastBuildingsBbox = null;
        let buildingLocations = [];  // Array of [lat, lng] coordinates from buildings

        /**
         * Compute bounding box around a center point given a radius in km
         * Uses simple lat/lng offset approximation (accurate enough for city scale)
         */
        function computeBbox(lat, lng, radiusKm) {
            const R = 6371; // Earth radius in km
            const latOffset = (radiusKm / R) * (180 / Math.PI);
            const lngOffset = (radiusKm / R) * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);

            return {
                south: lat - latOffset,
                west: lng - lngOffset,
                north: lat + latOffset,
                east: lng + lngOffset
            };
        }

        /**
         * Fetch building footprints from Overpass API
         * @param {number} radiusKm - Radius around hub to fetch buildings
         * @returns {Promise<void>}
         */
        async function fetchBuildings(radiusKm) {
            const bbox = computeBbox(HUB_LAT, HUB_LNG, radiusKm);

            // Check if we already have buildings for this bbox (within tolerance)
            if (buildingsCache && lastBuildingsBbox) {
                const tolerance = 0.5; // 500m tolerance
                const radiusDiff = Math.abs(
                    Math.sqrt(
                        Math.pow((bbox.north - bbox.south) / 2, 2) +
                        Math.pow((bbox.east - bbox.west) / 2, 2)
                    ) - Math.sqrt(
                        Math.pow((lastBuildingsBbox.north - lastBuildingsBbox.south) / 2, 2) +
                        Math.pow((lastBuildingsBbox.east - lastBuildingsBbox.west) / 2, 2)
                    )
                );

                if (radiusDiff < tolerance) {
                    console.log('Using cached buildings (bbox similar)');
                    return;
                }
            }

            // Construct Overpass QL query
            const query = `
[out:json][timeout:25];
(
  way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east});
  relation["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east});
);
out geom;
            `.trim();

            console.log('Fetching buildings from Overpass API...');
            console.log('Bbox:', bbox);

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query,
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    }
                });

                if (!response.ok) {
                    throw new Error(`Overpass API returned ${response.status}`);
                }

                const data = await response.json();
                console.log(`Received ${data.elements?.length || 0} building elements`);

                // Convert OSM JSON to GeoJSON using osmtogeojson
                const geojson = osmtogeojson(data);

                // Extract building locations for delivery sampling
                buildingLocations = [];
                if (geojson.features) {
                    geojson.features.forEach(feature => {
                        if (feature.geometry) {
                            if (feature.geometry.type === 'Point') {
                                // Point geometry
                                const [lng, lat] = feature.geometry.coordinates;
                                buildingLocations.push([lat, lng]);
                            } else if (feature.geometry.type === 'Polygon') {
                                // Polygon - use centroid
                                const coords = feature.geometry.coordinates[0];
                                if (coords.length > 0) {
                                    let sumLat = 0, sumLng = 0;
                                    coords.forEach(([lng, lat]) => {
                                        sumLat += lat;
                                        sumLng += lng;
                                    });
                                    buildingLocations.push([sumLat / coords.length, sumLng / coords.length]);
                                }
                            } else if (feature.geometry.type === 'MultiPolygon') {
                                // MultiPolygon - use centroid of first polygon
                                const coords = feature.geometry.coordinates[0][0];
                                if (coords.length > 0) {
                                    let sumLat = 0, sumLng = 0;
                                    coords.forEach(([lng, lat]) => {
                                        sumLat += lat;
                                        sumLng += lng;
                                    });
                                    buildingLocations.push([sumLat / coords.length, sumLng / coords.length]);
                                }
                            }
                        }
                    });
                }

                console.log(`Extracted ${buildingLocations.length} building locations for delivery sampling`);

                // Clear existing buildings
                buildingsLayer.clearLayers();

                // Add buildings to map with white outlines (dark theme)
                L.geoJSON(geojson, {
                    style: {
                        color: '#ffffff',      // White outlines
                        weight: 1,             // Thin lines
                        fillColor: 'none',     // No fill
                        fillOpacity: 0,        // Transparent fill
                        opacity: 0.6           // Semi-transparent outlines
                    },
                    onEachFeature: (feature, layer) => {
                        // Optional: add popup with building info
                        if (feature.properties) {
                            const props = feature.properties;
                            let popupContent = '<b>Building</b>';
                            if (props.name) popupContent += `<br>${props.name}`;
                            if (props['building:levels']) popupContent += `<br>Levels: ${props['building:levels']}`;
                            layer.bindPopup(popupContent);
                        }
                    }
                }).addTo(buildingsLayer);

                // Cache the results
                buildingsCache = geojson;
                lastBuildingsBbox = bbox;

                console.log('Buildings rendered successfully');

            } catch (error) {
                console.error('Failed to fetch buildings:', error);

                // Try smaller bbox fallback if original radius was large
                if (radiusKm > 2) {
                    console.warn('Retrying with smaller bbox (2km radius)...');
                    try {
                        const smallerBbox = computeBbox(HUB_LAT, HUB_LNG, 2);
                        const smallerQuery = `
[out:json][timeout:15];
(
  way["building"](${smallerBbox.south},${smallerBbox.west},${smallerBbox.north},${smallerBbox.east});
  relation["building"](${smallerBbox.south},${smallerBbox.west},${smallerBbox.north},${smallerBbox.east});
);
out geom;
                        `.trim();

                        const fallbackResponse = await fetch('https://overpass-api.de/api/interpreter', {
                            method: 'POST',
                            body: smallerQuery,
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded'
                            }
                        });

                        if (fallbackResponse.ok) {
                            const fallbackData = await fallbackResponse.json();
                            const fallbackGeojson = osmtogeojson(fallbackData);

                            // Extract building locations from fallback
                            buildingLocations = [];
                            if (fallbackGeojson.features) {
                                fallbackGeojson.features.forEach(feature => {
                                    if (feature.geometry && feature.geometry.type === 'Polygon') {
                                        const coords = feature.geometry.coordinates[0];
                                        if (coords.length > 0) {
                                            let sumLat = 0, sumLng = 0;
                                            coords.forEach(([lng, lat]) => {
                                                sumLat += lat;
                                                sumLng += lng;
                                            });
                                            buildingLocations.push([sumLat / coords.length, sumLng / coords.length]);
                                        }
                                    }
                                });
                            }
                            console.log(`Fallback: Extracted ${buildingLocations.length} building locations`);

                            buildingsLayer.clearLayers();
                            L.geoJSON(fallbackGeojson, {
                                style: {
                                    color: '#ffffff',      // White outlines
                                    weight: 1,
                                    fillColor: 'none',
                                    fillOpacity: 0,
                                    opacity: 0.6
                                }
                            }).addTo(buildingsLayer);

                            buildingsCache = fallbackGeojson;
                            lastBuildingsBbox = smallerBbox;

                            console.log('Buildings rendered with smaller bbox');
                            return;
                        }
                    } catch (fallbackError) {
                        console.error('Fallback also failed:', fallbackError);
                    }
                }

                console.warn('Continuing without building footprints');
                // App remains functional without buildings
            }
        }

        /**
         * Fetch buildings for specific San Francisco neighborhoods
         * Loads Sunset, Richmond, and Bayview districts (high-density residential)
         */
        async function fetchSpecificDistricts() {
            console.log('Fetching buildings for Sunset, Richmond, and Bayview districts...');

            // Check if osmtogeojson is available
            if (typeof osmtogeojson === 'undefined') {
                throw new Error('osmtogeojson library not loaded');
            }
            console.log('osmtogeojson is available');

            // Define bounding boxes for each district (expanded for full coverage)
            const districts = [
                {
                    name: 'Richmond District (Outer & Inner)',
                    bbox: { south: 37.765, north: 37.805, west: -122.515, east: -122.430 }
                },
                {
                    name: 'Sunset District (Outer & Inner)',
                    bbox: { south: 37.720, north: 37.780, west: -122.515, east: -122.445 }
                },
                {
                    name: 'Bayview-Hunters Point',
                    bbox: { south: 37.700, north: 37.750, west: -122.415, east: -122.370 }
                },
                {
                    name: 'Mission & Excelsior',
                    bbox: { south: 37.710, north: 37.765, west: -122.445, east: -122.400 }
                },
                {
                    name: 'Western Addition & Haight',
                    bbox: { south: 37.765, north: 37.790, west: -122.450, east: -122.420 }
                }
            ];

            buildingLocations = [];
            let totalBuildings = 0;

            for (const district of districts) {
                try {
                    const bbox = district.bbox;
                    const query = `
[out:json][timeout:25];
(
  way["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east});
  relation["building"](${bbox.south},${bbox.west},${bbox.north},${bbox.east});
);
out geom;
                    `.trim();

                    console.log(`Fetching ${district.name}...`);
                    const response = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        body: query,
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded'
                        }
                    });

                    console.log(`Response status for ${district.name}: ${response.status}`);
                    if (!response.ok) {
                        console.warn(`Failed to fetch ${district.name}: ${response.status} ${response.statusText}`);
                        continue;
                    }

                    const data = await response.json();
                    console.log(`Data received for ${district.name}, elements:`, data.elements?.length);
                    const geojson = osmtogeojson(data);
                    console.log(`GeoJSON features for ${district.name}:`, geojson.features?.length);

                    // Extract building locations
                    if (geojson.features) {
                        geojson.features.forEach(feature => {
                            if (feature.geometry) {
                                if (feature.geometry.type === 'Polygon') {
                                    const coords = feature.geometry.coordinates[0];
                                    if (coords.length > 0) {
                                        let sumLat = 0, sumLng = 0;
                                        coords.forEach(([lng, lat]) => {
                                            sumLat += lat;
                                            sumLng += lng;
                                        });
                                        buildingLocations.push([sumLat / coords.length, sumLng / coords.length]);
                                    }
                                } else if (feature.geometry.type === 'MultiPolygon') {
                                    const coords = feature.geometry.coordinates[0][0];
                                    if (coords.length > 0) {
                                        let sumLat = 0, sumLng = 0;
                                        coords.forEach(([lng, lat]) => {
                                            sumLat += lat;
                                            sumLng += lng;
                                        });
                                        buildingLocations.push([sumLat / coords.length, sumLng / coords.length]);
                                    }
                                }
                            }
                        });
                    }

                    const districtBuildings = geojson.features?.length || 0;
                    totalBuildings += districtBuildings;
                    console.log(`✓ ${district.name}: ${districtBuildings} buildings`);

                    // Add buildings to map with white outlines (dark theme)
                    L.geoJSON(geojson, {
                        style: {
                            color: '#ffffff',      // White outlines
                            weight: 1,             // Thin lines
                            fillColor: 'none',     // No fill
                            fillOpacity: 0,        // Transparent fill
                            opacity: 0.6           // Semi-transparent outlines
                        }
                    }).addTo(buildingsLayer);

                    // Small delay between requests to be nice to Overpass API
                    await new Promise(resolve => setTimeout(resolve, 1000));

                } catch (error) {
                    console.error(`Error fetching ${district.name}:`, error);
                }
            }

            console.log(`✓ Total: ${totalBuildings} buildings, ${buildingLocations.length} delivery locations`);
            buildingsCache = { districts: true, count: buildingLocations.length };
        }

        // =============================================================================
        // UI Control Wiring
        // =============================================================================

        // Get all control elements
        const radiusSlider = document.getElementById('radius-slider');
        const radiusValue = document.getElementById('radius-value');
        const buildingsRadiusSlider = document.getElementById('buildings-radius-slider');
        const buildingsRadiusValue = document.getElementById('buildings-radius-value');
        const numDronesSlider = document.getElementById('num-drones-slider');
        const numDronesValue = document.getElementById('num-drones-value');
        const ordersPerHourSlider = document.getElementById('orders-per-hour-slider');
        const ordersPerHourValue = document.getElementById('orders-per-hour-value');
        const timeScaleSlider = document.getElementById('time-scale-slider');
        const timeScaleValue = document.getElementById('time-scale-value');

        // Fleet optimizer controls
        const targetP95Slider = document.getElementById('target-p95-slider');
        const targetP95Value = document.getElementById('target-p95-value');
        const horizonSlider = document.getElementById('horizon-slider');
        const horizonValue = document.getElementById('horizon-value');
        const findNBtn = document.getElementById('find-n-btn');
        const optimizerStatus = document.getElementById('optimizer-status');

        // Control buttons
        const startBtn = document.getElementById('start-btn');
        const stopBtn = document.getElementById('stop-btn');
        const resetBtn = document.getElementById('reset-btn');

        // Update slider value displays
        radiusSlider.addEventListener('input', (e) => {
            radiusValue.textContent = `${parseFloat(e.target.value).toFixed(1)} km`;
        });

        buildingsRadiusSlider.addEventListener('input', (e) => {
            buildingsRadiusValue.textContent = `${parseFloat(e.target.value).toFixed(1)} km`;
        });

        numDronesSlider.addEventListener('input', (e) => {
            numDronesValue.textContent = e.target.value;
        });

        ordersPerHourSlider.addEventListener('input', (e) => {
            ordersPerHourValue.textContent = e.target.value;
        });

        timeScaleSlider.addEventListener('input', (e) => {
            timeScaleValue.textContent = `${parseFloat(e.target.value).toFixed(1)}x`;
        });

        targetP95Slider.addEventListener('input', (e) => {
            targetP95Value.textContent = e.target.value;
        });

        horizonSlider.addEventListener('input', (e) => {
            horizonValue.textContent = e.target.value;
        });

        // Fetch buildings when buildings radius changes (debounced)
        let buildingsFetchTimeout;
        buildingsRadiusSlider.addEventListener('change', (e) => {
            clearTimeout(buildingsFetchTimeout);
            buildingsFetchTimeout = setTimeout(() => {
                const radius = parseFloat(e.target.value);
                fetchBuildings(radius);
            }, 500);
        });

        // Initial building fetch
        const initialBuildingsRadius = parseFloat(buildingsRadiusSlider.value);
        fetchBuildings(initialBuildingsRadius);

        // =============================================================================
        // Core State Structures
        // =============================================================================

        /**
         * Simulation parameters (read from UI controls)
         */
        const params = {
            // Environment
            avgRadiusKm: 2.0,           // Average delivery radius
            buildingsRadiusKm: 3.0,     // Building fetch radius

            // Fleet
            numDrones: 10,              // Total drones available
            speedKmh: 70,               // Drone cruise speed (km/h)

            // Timing constants
            loadSec: 30,                // Package loading time at hub
            serviceAtDropSec: 30,       // Service time at delivery location
            turnaroundSec: 60,          // Reload/recharge time at hub

            // Demand
            ordersPerHour: 60,          // Order arrival rate

            // Simulation
            timeScale: 1.0              // Simulation speed multiplier
        };

        /**
         * Simulation state
         */
        const sim = {
            simT: 0,                    // Current simulation time (seconds)
            realT: 0,                   // Real time elapsed (seconds)
            running: false,             // Is simulation running?
            lastFrameTime: null,        // Last RAF timestamp (for dt calculation)
            orderAccumulator: 0,        // Fractional order accumulator for deterministic generation
            nextOrderTime: 0,           // Next order arrival time for Poisson process
            nextOrderId: 0,             // Counter for order IDs
            nextDroneId: 0              // Counter for drone IDs
        };

        /**
         * Orders array - all orders created
         * Each order: {
         *   id: number,
         *   lat: number,
         *   lng: number,
         *   tCreated: number,    // When order was placed
         *   tStart: number,      // When drone starts handling (after wait)
         *   tFinish: number,     // When delivery completes
         *   waitSec: number,     // Wait time = tStart - tCreated
         *   droneId: number,     // Which drone handled this
         *   marker: L.Marker     // Optional map marker
         * }
         */
        let orders = [];

        /**
         * Drones array - all drone state machines
         * Each drone: {
         *   id: number,
         *   availableAt: number,     // simT when drone is free
         *   queue: [segment, ...],   // Animation segments to render
         *   active: segment | null,  // Current segment being animated
         *   marker: L.Marker,        // Leaflet marker
         *   trail: L.Polyline,       // Trail showing current path
         *   trailCoords: [[lat,lng]],// Trail coordinate history
         *   lat: number,             // Current latitude
         *   lng: number              // Current longitude
         * }
         *
         * Each segment: {
         *   t0: number,              // Start time
         *   t1: number,              // End time
         *   fromLat: number,
         *   fromLng: number,
         *   toLat: number,
         *   toLng: number
         * }
         */
        let drones = [];

        /**
         * Pending completions min-heap (for accurate real-time metrics)
         * Each entry: { tFinish: number, order: Order }
         * Kept sorted by tFinish (earliest first)
         *
         * Completion accounting flow:
         * 1. When order is scheduled → insertPendingCompletion() adds to heap
         * 2. Each sim tick → processCompletions() pops orders where tFinish <= simT
         * 3. Metrics update → streaming stats (avgWait, p95) updated incrementally
         *
         * This provides accurate real-time metrics vs. marking complete at schedule time
         */
        let pendingCompletions = [];

        /**
         * Completed orders (for metrics calculation)
         */
        let completedOrders = [];

        /**
         * Wait time buffer for P95 calculation (ring buffer, last N waits)
         */
        const WAIT_BUFFER_SIZE = 2000;
        let waitBuffer = new Array(WAIT_BUFFER_SIZE).fill(0);
        let waitBufferIndex = 0;

        /**
         * Streaming metrics (updated incrementally)
         */
        let avgWaitSec = 0;        // Incremental mean of wait times
        let avgDeliverySec = 0;    // Incremental mean of total delivery times (order → drop-off)
        let numCompleted = 0;      // Total completed orders

        /**
         * Rendering policy configuration
         */
        const RENDER_ORDER_MARKERS = true;    // Set to false to skip order markers entirely
        const MAX_ORDER_MARKERS = 200;         // Cap on visible order markers for performance
        let orderMarkersVisible = [];          // Track visible order markers for cleanup

        /**
         * Order generation mode
         */
        const USE_POISSON_ARRIVALS = true;  // true = random Poisson arrivals, false = deterministic

        /**
         * Performance guardrails and sanity caps
         *
         * These limits ensure the demo stays responsive even under stress:
         *
         * 1. Order markers: Capped at MAX_ORDER_MARKERS (200)
         *    - Prevents DOM bloat with thousands of markers
         *    - FIFO queue automatically removes oldest markers
         *
         * 2. Wait buffer: Capped at WAIT_BUFFER_SIZE (2000)
         *    - Ring buffer for P95 calculation
         *    - Bounded memory, O(n log n) sort for P95 is fast at this scale
         *
         * 3. Buildings cache: Fetched once, cached, persists across resets
         *    - 500m tolerance before re-fetching
         *    - Smaller bbox (2km) fallback on Overpass API failure
         *    - Max radius capped at MAX_BUILDINGS_RADIUS (10km)
         *    - App remains functional if buildings fail to load
         *
         * 4. Orders per hour: Capped at MAX_ORDERS_PER_HOUR (1000)
         *    - Allows extreme stress testing of fleet capacity
         *    - At 1000 orders/hr ≈ 16.7 orders/sec (very high volume)
         *    - Combined with timeScale, enables rapid capacity analysis
         *
         * 5. Time scale: Capped at MAX_TIME_SCALE (10x)
         *    - Allows fast-forward without extreme frame skipping
         *    - Decoupled from rendering (RAF at 60fps, sim can advance faster)
         */
        const MAX_ORDERS_PER_HOUR = 1000;      // UI hard cap (high capacity for stress testing)
        const MAX_TIME_SCALE = 50;             // UI hard cap (50x fast-forward max)
        const MAX_BUILDINGS_RADIUS = 10;       // Max buildings fetch radius (km)
        const BUILDINGS_FETCH_TIMEOUT = 25000; // Overpass API timeout (ms)

        // =============================================================================
        // RNG and Spatial Sampling
        // =============================================================================

        /**
         * Generate next order arrival time using Poisson process
         * Returns time interval (in seconds) until next order
         *
         * For Poisson process with rate λ (orders per second),
         * inter-arrival times follow exponential distribution: -ln(u)/λ
         *
         * @param {number} ordersPerHour - Expected order rate per hour
         * @returns {number} Time in seconds until next order
         */
        function samplePoissonInterval(ordersPerHour) {
            const lambda = ordersPerHour / 3600; // Convert to orders per second
            const u = Math.random();
            return -Math.log(u) / lambda;
        }

        /**
         * Calculate distance between two lat/lng points using equirectangular approximation
         * Accurate to ~1% for distances < 50km at mid-latitudes
         *
         * @param {number} lat1 - First point latitude (degrees)
         * @param {number} lng1 - First point longitude (degrees)
         * @param {number} lat2 - Second point latitude (degrees)
         * @param {number} lng2 - Second point longitude (degrees)
         * @returns {number} Distance in kilometers
         */
        function distanceKm(lat1, lng1, lat2, lng2) {
            const R = 6371; // Earth radius in km
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            const lng1Rad = lng1 * Math.PI / 180;
            const lng2Rad = lng2 * Math.PI / 180;

            const x = (lng2Rad - lng1Rad) * Math.cos((lat1Rad + lat2Rad) / 2);
            const y = lat2Rad - lat1Rad;

            return Math.sqrt(x * x + y * y) * R;
        }

        /**
         * Sample a random delivery location from actual building locations
         * Only returns buildings within the specified delivery radius
         * Falls back to uniform-in-disk if buildings not loaded
         *
         * @param {number} hubLat - Hub latitude (degrees)
         * @param {number} hubLng - Hub longitude (degrees)
         * @param {number} avgRadiusKm - Average delivery radius (km)
         * @returns {object} Object with {lat, lng} in degrees
         */
        function sampleOrder(hubLat, hubLng, avgRadiusKm) {
            // If we have building locations, sample from them
            if (buildingLocations.length > 0) {
                // Pre-filter buildings within delivery radius for better performance
                // (Do this filtering on-demand rather than caching to handle dynamic radius changes)
                const maxAttempts = 100;
                let attempts = 0;

                while (attempts < maxAttempts) {
                    // Random building from full set
                    const randomIndex = Math.floor(Math.random() * buildingLocations.length);
                    const [lat, lng] = buildingLocations[randomIndex];

                    // Check if within delivery radius
                    const dist = distanceKm(hubLat, hubLng, lat, lng);

                    // Strict radius check - only use buildings within specified radius
                    if (dist <= avgRadiusKm) {
                        return { lat, lng };
                    }

                    attempts++;
                }

                // If we've tried 100 times and can't find a building in radius,
                // either the radius is too small or buildings don't cover the area
                console.warn(`Could not find building within ${avgRadiusKm}km radius after ${maxAttempts} attempts. Total buildings: ${buildingLocations.length}. Consider increasing Buildings Radius or loading more districts.`);

                // Fall through to uniform-in-disk as backup
            }

            // Fallback: uniform-in-disk distribution (if buildings not loaded)
            // Sample radius: r = R * sqrt(u) gives uniform area distribution
            // Use R = 1.5 * avgRadiusKm so E[r] ≈ avgRadiusKm
            const r = 1.5 * avgRadiusKm * Math.sqrt(Math.random());

            // Sample angle uniformly
            const theta = 2 * Math.PI * Math.random();

            // Convert polar to Cartesian offset (km)
            const dx = r * Math.cos(theta); // East-west offset in km
            const dy = r * Math.sin(theta); // North-south offset in km

            // Convert km offsets to degrees using small-distance approximation
            // 1 degree latitude ≈ 111 km everywhere
            // 1 degree longitude ≈ 111 km * cos(latitude) at given latitude
            const hubLatRad = hubLat * Math.PI / 180;
            const dLat = dy / 111.0;
            const dLng = dx / (111.0 * Math.cos(hubLatRad));

            return {
                lat: hubLat + dLat,
                lng: hubLng + dLng
            };
        }

        // =============================================================================
        // Timing Model (The Only Physics)
        // =============================================================================

        /**
         * Calculate one-way flight time in seconds
         *
         * @param {number} distKm - Distance to fly (km)
         * @param {number} speedKmh - Drone speed (km/h)
         * @returns {number} Flight time in seconds
         */
        function calculateFlyTime(distKm, speedKmh) {
            return (distKm / speedKmh) * 3600;
        }

        /**
         * Calculate total busy time for a delivery (seconds)
         * This is the complete cycle from assignment to drone becoming available again
         *
         * Timeline:
         *   t0: Order assigned to drone
         *   t0 → t1: Load package at hub (loadSec)
         *   t1 → t2: Fly to delivery location (flyOneSec)
         *   t2 → t3: Service at drop-off (serviceAtDropSec)
         *   t3 → t4: Fly back to hub (flyOneSec)
         *   t4 → t5: Turnaround at hub (turnaroundSec)
         *   t5: Drone available for next order
         *
         * @param {number} distKm - One-way distance (km)
         * @param {object} params - Simulation parameters
         * @returns {number} Total busy time in seconds
         */
        function calculateBusyTime(distKm, params) {
            const flyOneSec = calculateFlyTime(distKm, params.speedKmh);
            const busySec = params.loadSec +
                           flyOneSec +
                           params.serviceAtDropSec +
                           flyOneSec +
                           params.turnaroundSec;
            return busySec;
        }

        /**
         * Calculate detailed timing breakdown for a delivery
         * Returns all intermediate timestamps for animation
         *
         * @param {number} tStart - When drone starts handling order (after wait)
         * @param {number} distKm - One-way distance (km)
         * @param {object} params - Simulation parameters
         * @returns {object} Timing breakdown with t0-t5 and durations
         */
        function calculateTimingBreakdown(tStart, distKm, params) {
            const flyOneSec = calculateFlyTime(distKm, params.speedKmh);

            const t0 = tStart;                                          // Assignment
            const t1 = t0 + params.loadSec;                            // Load complete, start outbound
            const t2 = t1 + flyOneSec;                                 // Arrive at delivery
            const t3 = t2 + params.serviceAtDropSec;                   // Service complete, start return
            const t4 = t3 + flyOneSec;                                 // Arrive back at hub
            const t5 = t4 + params.turnaroundSec;                      // Turnaround complete, available

            return {
                t0, t1, t2, t3, t4, t5,
                loadSec: params.loadSec,
                flyOneSec,
                serviceAtDropSec: params.serviceAtDropSec,
                turnaroundSec: params.turnaroundSec,
                busySec: t5 - t0
            };
        }

        // =============================================================================
        // Helper Functions
        // =============================================================================

        /**
         * Read current parameters from UI controls
         * Enforces sanity caps for performance and stability
         *
         * UI Control Mappings:
         * - radius-slider → params.avgRadiusKm (delivery_radius_km)
         * - buildings-radius-slider → params.buildingsRadiusKm (buildings_radius_km)
         * - num-drones-slider → params.numDrones (num_drones)
         * - speed-input → params.speedKmh (drone_speed_kmh)
         * - load-time-input → params.loadSec (load_time_s)
         * - service-time-input → params.serviceAtDropSec (service_time_s)
         * - turnaround-time-input → params.turnaroundSec (turnaround_time_s)
         * - orders-per-hour-slider → params.ordersPerHour (orders_per_hour)
         * - time-scale-slider → params.timeScale (time_scale)
         */
        function readParams() {
            // Delivery radius (km)
            params.avgRadiusKm = parseFloat(radiusSlider.value);

            // Buildings fetch radius (km) - capped at MAX_BUILDINGS_RADIUS
            params.buildingsRadiusKm = Math.min(
                parseFloat(buildingsRadiusSlider.value),
                MAX_BUILDINGS_RADIUS
            );

            // Fleet size
            params.numDrones = parseInt(numDronesSlider.value);

            // Drone speed (km/h)
            params.speedKmh = parseFloat(document.getElementById('speed-input').value);

            // Timing parameters (seconds)
            params.loadSec = parseFloat(document.getElementById('load-time-input').value);
            params.serviceAtDropSec = parseFloat(document.getElementById('service-time-input').value);
            params.turnaroundSec = parseFloat(document.getElementById('turnaround-time-input').value);

            // Demand rate (orders/hour) - capped at MAX_ORDERS_PER_HOUR
            params.ordersPerHour = Math.min(
                parseInt(ordersPerHourSlider.value),
                MAX_ORDERS_PER_HOUR
            );

            // Simulation speed multiplier - capped at MAX_TIME_SCALE
            params.timeScale = Math.min(
                parseFloat(timeScaleSlider.value),
                MAX_TIME_SCALE
            );
        }

        /**
         * Insert order into pendingCompletions min-heap, maintaining sort order
         *
         * Completion accounting approach:
         * - Orders are scheduled immediately when created (greedy assignment)
         * - tFinish is known at scheduling time, but order isn't "completed" yet
         * - For accurate live metrics, track completion when simT >= tFinish
         * - Use min-heap sorted by tFinish for efficient processing
         * - Each sim tick, pop all orders with tFinish <= simT
         *
         * This gives real-time accuracy vs. marking complete at scheduling time
         */
        function insertPendingCompletion(order) {
            const entry = { tFinish: order.tFinish, order };

            // Binary search insert position to maintain sorted order
            let left = 0;
            let right = pendingCompletions.length;

            while (left < right) {
                const mid = Math.floor((left + right) / 2);
                if (pendingCompletions[mid].tFinish < entry.tFinish) {
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }

            pendingCompletions.splice(left, 0, entry);
        }

        /**
         * Process all completions up to current simT
         * Updates streaming metrics incrementally
         */
        function processCompletions() {
            while (pendingCompletions.length > 0 && pendingCompletions[0].tFinish <= sim.simT) {
                const { order } = pendingCompletions.shift();

                // Add to completed orders
                completedOrders.push(order);
                numCompleted++;

                // Update average wait time using incremental mean
                // Formula: avgNew = (avgOld * (n-1) + newValue) / n
                avgWaitSec = (avgWaitSec * (numCompleted - 1) + order.waitSec) / numCompleted;

                // Update average delivery time (order → drop-off complete)
                avgDeliverySec = (avgDeliverySec * (numCompleted - 1) + order.deliverySec) / numCompleted;

                // Update wait time buffer for P95 (ring buffer)
                waitBuffer[waitBufferIndex % WAIT_BUFFER_SIZE] = order.waitSec;
                waitBufferIndex++;

                // Remove order marker from map when order completes
                if (order.marker) {
                    ordersLayer.removeLayer(order.marker);
                    order.marker = null;

                    // Remove from visible markers tracking array
                    const index = orderMarkersVisible.findIndex(item => item.order.id === order.id);
                    if (index !== -1) {
                        orderMarkersVisible.splice(index, 1);
                    }
                }
            }
        }

        /**
         * Format seconds as HH:MM:SS
         */
        function formatTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        }

        /**
         * Format seconds as human-readable duration (e.g., "2m 30s")
         */
        function formatDuration(seconds) {
            if (seconds < 60) {
                return `${Math.round(seconds)}s`;
            } else if (seconds < 3600) {
                const m = Math.floor(seconds / 60);
                const s = Math.round(seconds % 60);
                return s > 0 ? `${m}m ${s}s` : `${m}m`;
            } else {
                const h = Math.floor(seconds / 3600);
                const m = Math.round((seconds % 3600) / 60);
                return m > 0 ? `${h}h ${m}m` : `${h}h`;
            }
        }

        // =============================================================================
        // Marker Creation and Management
        // =============================================================================

        /**
         * Create a drone marker at specified position
         *
         * @param {number} lat - Latitude
         * @param {number} lng - Longitude
         * @returns {L.Marker} Leaflet marker
         */
        function createDroneMarker(lat, lng) {
            // Create custom drone icon with rotation support
            const droneIcon = L.divIcon({
                className: 'drone-marker',
                html: '<div class="drone-icon">▲</div>',  // Triangle pointing up (will rotate to face direction)
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });

            const marker = L.marker([lat, lng], {
                icon: droneIcon,
                zIndexOffset: 1000,  // Keep drones on top
                rotationAngle: 0     // Initial rotation
            });

            return marker;
        }

        /**
         * Calculate bearing (heading) from one point to another
         * Returns angle in degrees (0 = North, 90 = East, 180 = South, 270 = West)
         *
         * @param {number} lat1 - Start latitude
         * @param {number} lng1 - Start longitude
         * @param {number} lat2 - End latitude
         * @param {number} lng2 - End longitude
         * @returns {number} Bearing in degrees
         */
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;

            const y = Math.sin(dLng) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                      Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);

            const bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360; // Normalize to 0-360
        }

        /**
         * Create a large, opaque red dot marker for an order delivery location
         * Disappears automatically when order is fulfilled
         *
         * @param {number} lat - Latitude
         * @param {number} lng - Longitude
         * @returns {L.CircleMarker} Leaflet circle marker
         */
        function createOrderMarker(lat, lng) {
            const marker = L.circleMarker([lat, lng], {
                radius: 7,              // Large, visible dot
                fillColor: '#ff0000',   // Bright red
                color: '#cc0000',       // Dark red border
                weight: 2,              // Thicker border
                opacity: 1.0,           // Fully opaque border
                fillOpacity: 1.0        // Fully opaque fill
            });

            return marker;
        }

        /**
         * Add an order marker to the map with cap management
         * Maintains at most MAX_ORDER_MARKERS visible markers
         *
         * @param {object} order - Order object with lat/lng
         */
        function addOrderMarker(order) {
            if (!RENDER_ORDER_MARKERS) return;

            // Create and add marker
            const marker = createOrderMarker(order.lat, order.lng);
            marker.addTo(ordersLayer);
            order.marker = marker;

            // Track visible markers
            orderMarkersVisible.push({ order, marker });

            // Remove oldest marker if over cap
            if (orderMarkersVisible.length > MAX_ORDER_MARKERS) {
                const oldest = orderMarkersVisible.shift();
                ordersLayer.removeLayer(oldest.marker);
                if (oldest.order.marker) {
                    oldest.order.marker = null;
                }
            }
        }

        // =============================================================================
        // Drone Scheduling (Greedy Earliest-Available)
        // =============================================================================

        /**
         * Find the drone with minimum availableAt time
         * For greedy scheduling - assign orders to earliest-available drone
         *
         * @returns {object} Drone with minimum availableAt
         */
        function findAvailableDrone() {
            let minDrone = drones[0];
            let minTime = drones[0].availableAt;

            for (let i = 1; i < drones.length; i++) {
                if (drones[i].availableAt < minTime) {
                    minTime = drones[i].availableAt;
                    minDrone = drones[i];
                }
            }

            return minDrone;
        }

        /**
         * Schedule an order to a drone using greedy earliest-available rule
         * Updates order timing fields and drone availability
         *
         * @param {object} order - Order to schedule
         */
        function scheduleOrder(order) {
            // Find drone with minimum availableAt
            const drone = findAvailableDrone();

            // Calculate distance from hub to delivery location
            const distKm = distanceKm(hubLat, hubLng, order.lat, order.lng);

            // Calculate total busy time for this delivery
            const busySec = calculateBusyTime(distKm, params);

            // Order starts when both order exists AND drone is free
            const tStart = Math.max(order.tCreated, drone.availableAt);

            // Update order timing fields
            order.waitSec = tStart - order.tCreated;
            order.tStart = tStart;
            order.tFinish = tStart + busySec;
            order.droneId = drone.id;

            // Get detailed timing breakdown for animation
            const timing = calculateTimingBreakdown(tStart, distKm, params);

            // Calculate total delivery time (order creation → package drop-off complete)
            // This includes: wait + load + outbound flight + service
            // Does NOT include return flight or turnaround
            order.deliverySec = timing.t3 - order.tCreated;

            // Create animation segments for this delivery
            // Segment 1: Hub → Delivery (starts after load time)
            const outboundSegment = {
                t0: timing.t1,  // After loading
                t1: timing.t2,  // Arrival at delivery
                fromLat: hubLat,
                fromLng: hubLng,
                toLat: order.lat,
                toLng: order.lng,
                type: 'outbound',
                orderId: order.id
            };

            // Segment 2: Delivery → Hub (starts after service time)
            const returnSegment = {
                t0: timing.t3,  // After service
                t1: timing.t4,  // Arrival at hub
                fromLat: order.lat,
                fromLng: order.lng,
                toLat: hubLat,
                toLng: hubLng,
                type: 'return',
                orderId: order.id
            };

            // Add segments to drone's animation queue
            drone.queue.push(outboundSegment);
            drone.queue.push(returnSegment);

            // Update drone availability (after complete cycle including turnaround)
            drone.availableAt = order.tFinish;

            // Add to pending completions for metrics tracking
            insertPendingCompletion(order);

            // Add order marker to map (with cap for performance)
            addOrderMarker(order);

            console.log(`Order ${order.id} scheduled to drone ${drone.id}: wait=${order.waitSec.toFixed(1)}s, finish at t=${order.tFinish.toFixed(1)}s`);
        }

        // =============================================================================
        // Simulation Control Functions
        // =============================================================================

        /**
         * Reset simulation to initial state
         *
         * Clears:
         * - All simulation state (simT, accumulators, counters)
         * - All data arrays (orders, completions, metrics buffers)
         * - Map layers (drones and orders - buildings are cached)
         *
         * Rebuilds:
         * - Drone fleet at hub (count from params.numDrones)
         * - Metrics display
         *
         * Optionally:
         * - Re-fetches buildings if bbox changed (internal caching prevents redundant fetches)
         */
        function reset() {
            console.log('Resetting simulation...');

            // Read current parameters from UI
            readParams();
            console.log('Params after readParams():', {
                ordersPerHour: params.ordersPerHour,
                numDrones: params.numDrones,
                avgRadiusKm: params.avgRadiusKm,
                timeScale: params.timeScale
            });

            // Reset simulation state
            sim.simT = 0;
            sim.realT = 0;
            sim.running = false;
            sim.lastFrameTime = null;
            sim.orderAccumulator = 0;
            sim.nextOrderTime = 0;
            sim.nextOrderId = 0;
            sim.nextDroneId = 0;

            // Clear data structures
            orders = [];
            completedOrders = [];
            pendingCompletions = [];
            orderMarkersVisible = [];

            // Reset streaming metrics
            avgWaitSec = 0;
            avgDeliverySec = 0;
            numCompleted = 0;
            waitBuffer = new Array(WAIT_BUFFER_SIZE).fill(0);
            waitBufferIndex = 0;

            // Remove old drone trails
            drones.forEach(d => {
                if (d.trail) {
                    dronesLayer.removeLayer(d.trail);
                }
            });

            // Clear all map layers (drones and orders)
            // Note: Buildings layer is NOT cleared - it's cached and persists
            ordersLayer.clearLayers();
            dronesLayer.clearLayers();

            // Create drones at hub
            drones = Array.from({ length: params.numDrones }, (_, i) => {
                const marker = createDroneMarker(hubLat, hubLng);
                marker.addTo(dronesLayer);

                // Create trail polyline (initially empty)
                const trail = L.polyline([], {
                    color: '#3498db',
                    weight: 4,
                    opacity: 1.0,
                    smoothFactor: 1
                }).addTo(dronesLayer);

                return {
                    id: i,
                    availableAt: 0,
                    queue: [],
                    active: null,
                    marker: marker,
                    trail: trail,
                    trailCoords: [],
                    lat: hubLat,
                    lng: hubLng
                };
            });

            console.log(`Created ${drones.length} drones at hub (${hubLat}, ${hubLng})`);

            // Ensure buildings are loaded for at least the delivery radius
            // This guarantees all potential delivery locations have buildings data
            const requiredRadius = Math.max(params.avgRadiusKm * 1.2, params.buildingsRadiusKm);
            console.log(`Ensuring buildings loaded for ${requiredRadius.toFixed(1)}km radius (delivery: ${params.avgRadiusKm}km)`);
            fetchBuildings(requiredRadius);

            // Report how many buildings are available within delivery radius
            if (buildingLocations.length > 0) {
                const buildingsInRadius = buildingLocations.filter(([lat, lng]) => {
                    return distanceKm(hubLat, hubLng, lat, lng) <= params.avgRadiusKm;
                }).length;
                console.log(`Buildings within delivery radius (${params.avgRadiusKm}km): ${buildingsInRadius} / ${buildingLocations.length} total`);

                if (buildingsInRadius < 100) {
                    console.warn(`⚠️ Only ${buildingsInRadius} buildings in delivery radius! Consider increasing Buildings Radius or loading SF Districts.`);
                }
            }

            // Reset metrics display
            updateMetricsUI();

            // Update button states
            startBtn.disabled = false;
            stopBtn.disabled = true;

            // Update status badge
            const statusBadge = document.getElementById('status-badge');
            if (statusBadge) {
                statusBadge.textContent = 'Idle';
                statusBadge.className = 'status-badge status-idle';
            }
        }

        /**
         * Start simulation
         *
         * - Sets running = true
         * - Initializes lastFrameTime for delta calculation
         * - Begins RAF (requestAnimationFrame) loop
         * - Preserves all state from pause/stop
         */
        function start() {
            if (sim.running) return;

            console.log('Starting simulation...');
            sim.running = true;
            sim.lastFrameTime = performance.now();
            requestAnimationFrame(animate);

            // Update button states
            startBtn.disabled = true;
            stopBtn.disabled = false;

            // Update status badge
            const statusBadge = document.getElementById('status-badge');
            if (statusBadge) {
                statusBadge.textContent = 'Running';
                statusBadge.className = 'status-badge status-running';
            }
        }

        /**
         * Stop simulation (pause)
         *
         * - Sets running = false
         * - RAF loop exits at next frame
         * - Simulation clock freezes (simT stops advancing)
         * - All state preserved (drones, orders, metrics)
         * - Can resume with start()
         */
        function stop() {
            if (!sim.running) return;

            console.log('Stopping simulation...');
            sim.running = false;
            // Simulation clock freezes, but state is preserved

            // Update button states
            startBtn.disabled = false;
            stopBtn.disabled = true;

            // Update status badge
            const statusBadge = document.getElementById('status-badge');
            if (statusBadge) {
                statusBadge.textContent = 'Paused';
                statusBadge.className = 'status-badge status-paused';
            }
        }

        /**
         * Update metrics display in UI
         * Reads from streaming metrics (avgWaitSec, numCompleted)
         * Computes P95 on-demand from ring buffer
         * Called every ~250ms, not every frame
         */
        function updateMetricsUI() {
            // Queue size = pending orders waiting for completion
            const queueSize = orders.length - numCompleted;

            // P95 wait time - compute from ring buffer
            // Copy and sort valid portion of buffer (fast enough at MVP scale)
            let p95WaitSec = 0;
            if (numCompleted > 0) {
                // Get valid portion of ring buffer
                const validCount = Math.min(numCompleted, WAIT_BUFFER_SIZE);
                const validWaits = waitBuffer.slice(0, validCount);

                // Sort and find 95th percentile
                const sorted = [...validWaits].sort((a, b) => a - b);
                const p95Index = Math.floor(sorted.length * 0.95);
                p95WaitSec = sorted[Math.min(p95Index, sorted.length - 1)];
            }

            // Calculate active drones (drones currently flying)
            const activeDrones = drones.filter(d => d.active !== null || d.queue.length > 0).length;

            // Calculate effective speed ratio
            const effectiveSpeed = sim.realT > 0 ? sim.simT / sim.realT : 1.0;

            // Calculate actual order generation rate (orders per hour in sim time)
            const totalOrders = orders.length;
            const simHours = sim.simT / 3600;
            const actualOrderRate = simHours > 0 ? totalOrders / simHours : 0;

            // Update DOM elements
            document.getElementById('avg-delivery-stat').textContent = formatDuration(avgDeliverySec);
            document.getElementById('p95-wait-stat').textContent = formatDuration(p95WaitSec);
            document.getElementById('completed-stat').textContent = numCompleted;
            document.getElementById('queue-stat').textContent = queueSize;
            document.getElementById('active-drones-stat').textContent = activeDrones;
            document.getElementById('total-orders-stat').textContent = totalOrders;
            document.getElementById('actual-rate-stat').textContent = actualOrderRate > 0 ? `${Math.round(actualOrderRate)}/hr` : '--';
            document.getElementById('sim-time-stat').textContent = formatTime(sim.simT);
            document.getElementById('real-time-stat').textContent = formatTime(sim.realT);
            document.getElementById('speed-stat').textContent = `${effectiveSpeed.toFixed(1)}x`;
        }

        // =============================================================================
        // Wire up control buttons
        // =============================================================================

        startBtn.addEventListener('click', start);
        stopBtn.addEventListener('click', stop);
        resetBtn.addEventListener('click', reset);
        findNBtn.addEventListener('click', runFleetOptimizer);

        // Initial reset to set up drones
        reset();

        // =============================================================================
        // Fleet Optimizer (Offline Simulation)
        // =============================================================================

        /**
         * Run offline simulation without animation or map updates
         * Returns P95 wait time for the given fleet size
         *
         * @param {number} numDrones - Fleet size to test
         * @param {number} horizonSec - Simulation duration (seconds)
         * @param {object} testParams - Parameters to use for simulation
         * @returns {number} P95 wait time in seconds
         */
        function runOfflineSimulation(numDrones, horizonSec, testParams) {
            // Offline simulation state
            let offlineSimT = 0;
            let offlineOrderAccum = 0;
            let offlineOrderId = 0;
            const offlineOrders = [];
            const offlineWaitTimes = [];

            // Create offline drone fleet
            const offlineDrones = Array.from({ length: numDrones }, (_, i) => ({
                id: i,
                availableAt: 0
            }));

            // Simulation step size (1 second)
            const dt = 1.0;

            // Run simulation for horizon
            while (offlineSimT < horizonSec) {
                // Generate orders using per-second accumulator
                offlineOrderAccum += testParams.ordersPerHour / 3600;

                while (offlineOrderAccum >= 1.0) {
                    // Create order
                    const location = sampleOrder(hubLat, hubLng, testParams.avgRadiusKm);
                    const order = {
                        id: offlineOrderId++,
                        lat: location.lat,
                        lng: location.lng,
                        tCreated: offlineSimT
                    };

                    // Schedule to earliest available drone
                    let minDrone = offlineDrones[0];
                    for (let i = 1; i < offlineDrones.length; i++) {
                        if (offlineDrones[i].availableAt < minDrone.availableAt) {
                            minDrone = offlineDrones[i];
                        }
                    }

                    // Calculate timing
                    const distKm = distanceKm(hubLat, hubLng, order.lat, order.lng);
                    const busySec = calculateBusyTime(distKm, testParams);
                    const tStart = Math.max(order.tCreated, minDrone.availableAt);
                    const waitSec = tStart - order.tCreated;
                    const tFinish = tStart + busySec;

                    // Update drone
                    minDrone.availableAt = tFinish;

                    // Track order
                    order.waitSec = waitSec;
                    order.tFinish = tFinish;
                    offlineOrders.push(order);

                    // Add to wait times if completed within horizon
                    if (tFinish <= horizonSec) {
                        offlineWaitTimes.push(waitSec);
                    }

                    offlineOrderAccum -= 1.0;
                }

                offlineSimT += dt;
            }

            // Calculate P95 from wait times
            if (offlineWaitTimes.length === 0) {
                return 0;
            }

            const sorted = [...offlineWaitTimes].sort((a, b) => a - b);
            const p95Index = Math.floor(sorted.length * 0.95);
            const p95 = sorted[Math.min(p95Index, sorted.length - 1)];

            return p95;
        }

        /**
         * Find minimum number of drones to meet SLA using binary search
         * P95 wait time decreases monotonically with fleet size
         *
         * @param {number} targetP95Sec - Target P95 wait time (seconds)
         * @param {number} horizonSec - Simulation duration (seconds)
         * @param {object} testParams - Parameters to use for simulation
         * @returns {object} Result with {minDrones, achievedP95, iterations}
         */
        function findMinimumFleetSize(targetP95Sec, horizonSec, testParams) {
            let lo = 1;
            let hi = 500; // Max drones to search (reduced from 1000 for reasonable search time)
            let iterations = 0;
            let bestN = hi;
            let bestP95 = Infinity;

            while (lo < hi) {
                iterations++;
                const mid = Math.floor((lo + hi) / 2);

                console.log(`Testing fleet size: ${mid} (search range: ${lo}-${hi})`);
                const p95 = runOfflineSimulation(mid, horizonSec, testParams);
                console.log(`  → P95 wait: ${p95.toFixed(1)}s (target: ${targetP95Sec}s)`);

                if (p95 <= targetP95Sec) {
                    // SLA met, try smaller fleet
                    hi = mid;
                    bestN = mid;
                    bestP95 = p95;
                } else {
                    // SLA not met, need more drones
                    lo = mid + 1;
                }
            }

            return {
                minDrones: bestN,
                achievedP95: bestP95,
                iterations
            };
        }

        /**
         * Run fleet optimizer (triggered by button)
         */
        async function runFleetOptimizer() {
            // Disable button during optimization
            findNBtn.disabled = true;
            optimizerStatus.textContent = 'Running optimization...';
            optimizerStatus.style.color = '#007bff';

            // Read optimizer parameters
            const targetP95Min = parseInt(targetP95Slider.value);
            const targetP95Sec = targetP95Min * 60;
            const horizonHours = parseInt(horizonSlider.value);
            const horizonSec = horizonHours * 3600;

            // Read current simulation parameters
            readParams();

            console.log('=== Fleet Optimizer Started ===');
            console.log(`Target P95: ${targetP95Min} minutes (${targetP95Sec}s)`);
            console.log(`Horizon: ${horizonHours} hours (${horizonSec}s)`);
            console.log(`Demand: ${params.ordersPerHour} orders/hour`);

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                try {
                    const result = findMinimumFleetSize(targetP95Sec, horizonSec, params);

                    console.log('=== Optimization Complete ===');
                    console.log(`Minimum fleet size: ${result.minDrones} drones`);
                    console.log(`Achieved P95: ${result.achievedP95.toFixed(1)}s (${(result.achievedP95 / 60).toFixed(1)} min)`);
                    console.log(`Binary search iterations: ${result.iterations}`);

                    // Update UI
                    numDronesSlider.value = result.minDrones;
                    numDronesValue.textContent = result.minDrones;

                    optimizerStatus.innerHTML = `
                        ✓ Found optimal fleet: <strong>${result.minDrones} drones</strong><br>
                        P95 wait: ${formatDuration(result.achievedP95)} (target: ${targetP95Min}m)<br>
                        <small>Click Reset and Start to see animated simulation</small>
                    `;
                    optimizerStatus.style.color = '#28a745';

                } catch (error) {
                    console.error('Optimization failed:', error);
                    optimizerStatus.textContent = `Error: ${error.message}`;
                    optimizerStatus.style.color = '#dc3545';
                } finally {
                    findNBtn.disabled = false;
                }
            }, 50);
        }

        // =============================================================================
        // Animation Loop (60 FPS via RAF)
        // =============================================================================

        /**
         * Linear interpolation
         *
         * @param {number} a - Start value
         * @param {number} b - End value
         * @param {number} t - Interpolation parameter [0, 1]
         * @returns {number} Interpolated value
         */
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        /**
         * Clamp value between 0 and 1
         *
         * @param {number} x - Value to clamp
         * @returns {number} Clamped value
         */
        function clamp01(x) {
            return Math.max(0, Math.min(1, x));
        }

        /**
         * Update all drone positions based on current simulation time
         * Handles animation segment progression and interpolation
         */
        function updateDronePositions() {
            for (const drone of drones) {
                // If no active segment and queue has segments, pop next one
                if (drone.active === null && drone.queue.length > 0) {
                    drone.active = drone.queue.shift();

                    // If starting a new outbound segment, clear old trail
                    if (drone.active && drone.active.type === 'outbound') {
                        drone.trailCoords = [[drone.lat, drone.lng]];
                        drone.trail.setLatLngs(drone.trailCoords);
                        drone.trail.setStyle({ color: '#e74c3c', weight: 4, opacity: 1.0 }); // Red for outbound
                    } else if (drone.active && drone.active.type === 'return') {
                        // Keep existing trail, just change color for return
                        drone.trail.setStyle({ color: '#2980b9', weight: 4, opacity: 1.0 }); // Blue for return
                    }
                }

                // If we have an active segment, animate it
                if (drone.active !== null) {
                    const seg = drone.active;

                    if (sim.simT < seg.t0) {
                        // Before segment starts - hold position (loading/servicing)
                        // Position is already set from previous segment or initialization
                        // No update needed
                    } else if (sim.simT >= seg.t1) {
                        // Segment complete - snap to destination
                        const prevLat = drone.lat;
                        const prevLng = drone.lng;
                        drone.lat = seg.toLat;
                        drone.lng = seg.toLng;

                        // Calculate final bearing
                        const finalBearing = calculateBearing(prevLat, prevLng, drone.lat, drone.lng);

                        // Add final position to trail
                        drone.trailCoords.push([drone.lat, drone.lng]);
                        drone.trail.setLatLngs(drone.trailCoords);

                        // Rotate to final bearing
                        const iconElement = drone.marker.getElement();
                        if (iconElement) {
                            const droneIcon = iconElement.querySelector('.drone-icon');
                            if (droneIcon) {
                                droneIcon.style.transform = `rotate(${finalBearing}deg)`;
                            }
                        }

                        // If this was a return segment, fade out and clear trail after delay
                        if (seg.type === 'return') {
                            setTimeout(() => {
                                drone.trailCoords = [];
                                drone.trail.setLatLngs([]);
                            }, 1000); // Clear trail 1 second after return completes
                        }

                        drone.active = null;
                    } else {
                        // During segment - interpolate position
                        const alpha = clamp01((sim.simT - seg.t0) / (seg.t1 - seg.t0));
                        const newLat = lerp(seg.fromLat, seg.toLat, alpha);
                        const newLng = lerp(seg.fromLng, seg.toLng, alpha);

                        // Calculate bearing for drone rotation
                        const bearing = calculateBearing(drone.lat, drone.lng, newLat, newLng);

                        // Update position
                        drone.lat = newLat;
                        drone.lng = newLng;

                        // Add position to trail (slightly behind current position)
                        // Use alpha with slight delay so trail doesn't overlap drone marker
                        const trailAlpha = Math.max(0, alpha - 0.05); // Trail 5% behind
                        const trailLat = lerp(seg.fromLat, seg.toLat, trailAlpha);
                        const trailLng = lerp(seg.fromLng, seg.toLng, trailAlpha);

                        // Add to trail (throttle to avoid too many points)
                        if (drone.trailCoords.length === 0 || Math.random() < 0.3) {
                            drone.trailCoords.push([trailLat, trailLng]);
                            drone.trail.setLatLngs(drone.trailCoords);
                        }

                        // Rotate drone icon to face direction of travel
                        const iconElement = drone.marker.getElement();
                        if (iconElement) {
                            const droneIcon = iconElement.querySelector('.drone-icon');
                            if (droneIcon) {
                                droneIcon.style.transform = `rotate(${bearing}deg)`;
                            }
                        }
                    }

                    // Update marker position on map
                    drone.marker.setLatLng([drone.lat, drone.lng]);
                }
            }
        }

        /**
         * Main animation loop - runs at 60 FPS via requestAnimationFrame
         *
         * Rendering policy:
         * - Drones: Always rendered (typically < 50, low overhead)
         * - Orders: Capped at MAX_ORDER_MARKERS (200) for performance
         * - Buildings: Rendered once and cached, not cleared on reset
         *
         * Simulation/rendering decoupling:
         * - RAF runs at 60fps (rendering frequency)
         * - Simulation advances by dtReal * timeScale (can be much faster)
         * - High timeScale allows fast-forward without skipping frames
         *
         * @param {number} timestamp - High-resolution timestamp from RAF
         */
        function animate(timestamp) {
            if (!sim.running) return;

            // Calculate real-world time delta
            const dtReal = (timestamp - sim.lastFrameTime) / 1000; // Convert ms to seconds
            sim.lastFrameTime = timestamp;

            // Read current timeScale from slider in real-time (allows live adjustment)
            const sliderValue = parseFloat(timeScaleSlider.value);
            params.timeScale = isNaN(sliderValue) ? 1.0 : Math.min(Math.max(sliderValue, 0.1), MAX_TIME_SCALE);

            // Track both real time and simulation time
            sim.realT += dtReal;
            sim.simT += dtReal * params.timeScale;

            // Debug: Log first few frames and when timeScale changes
            const prevTimeScale = sim.lastTimeScale || params.timeScale;
            if (sim.simT < 5 || Math.abs(params.timeScale - prevTimeScale) > 0.1) {
                console.log(`Frame: realT=${sim.realT.toFixed(2)}s, simT=${sim.simT.toFixed(2)}s, timeScale=${params.timeScale.toFixed(1)}x, dtSim=${(dtReal * params.timeScale).toFixed(3)}s`);
                sim.lastTimeScale = params.timeScale;
            }

            // Generate orders based on selected mode
            if (USE_POISSON_ARRIVALS) {
                // Poisson process: random arrivals with exponentially distributed intervals
                // More realistic: arrival times vary randomly around the mean rate

                // Initialize next order time if not set
                if (sim.nextOrderTime === 0) {
                    sim.nextOrderTime = samplePoissonInterval(params.ordersPerHour);
                }

                // Check if it's time for next order
                while (sim.simT >= sim.nextOrderTime) {
                    // Sample random delivery location
                    const location = sampleOrder(hubLat, hubLng, params.avgRadiusKm);

                    // Create order object
                    const order = {
                        id: sim.nextOrderId++,
                        lat: location.lat,
                        lng: location.lng,
                        tCreated: sim.nextOrderTime
                    };

                    // Add to orders array
                    orders.push(order);

                    // Log first 10 orders and then every 50th order
                    if (order.id < 10 || order.id % 50 === 0) {
                        const expectedRate = params.ordersPerHour;
                        const actualRate = orders.length / (sim.simT / 3600);
                        console.log(`📦 Order ${order.id} created at simT=${sim.nextOrderTime.toFixed(1)}s | Expected: ${expectedRate}/hr | Actual: ${actualRate.toFixed(1)}/hr`);
                    }

                    // Schedule order to drone
                    scheduleOrder(order);

                    // Sample next arrival interval
                    const interval = samplePoissonInterval(params.ordersPerHour);
                    sim.nextOrderTime += interval;
                }
            } else {
                // Deterministic accumulator: constant arrival rate
                // Simpler but less realistic - orders arrive at exact intervals

                const simTimePassed = dtReal * params.timeScale;
                sim.orderAccumulator += (params.ordersPerHour / 3600) * simTimePassed;

                // Debug: Log accumulator periodically
                if (Math.floor(sim.simT) !== Math.floor(sim.simT - simTimePassed) && sim.simT < 10) {
                    console.log(`simT=${sim.simT.toFixed(1)}s, orderAccum=${sim.orderAccumulator.toFixed(3)}, ordersPerHour=${params.ordersPerHour}`);
                }

                // Spawn orders when accumulator >= 1
                while (sim.orderAccumulator >= 1.0) {
                    // Sample random delivery location
                    const location = sampleOrder(hubLat, hubLng, params.avgRadiusKm);

                    // Create order object
                    const order = {
                        id: sim.nextOrderId++,
                        lat: location.lat,
                        lng: location.lng,
                        tCreated: sim.simT
                    };

                    // Add to orders array
                    orders.push(order);

                    console.log(`📦 Order ${order.id} created at simT=${sim.simT.toFixed(1)}s (Deterministic), location=(${order.lat.toFixed(4)}, ${order.lng.toFixed(4)})`);

                    // Schedule order to drone
                    scheduleOrder(order);

                    // Decrement accumulator
                    sim.orderAccumulator -= 1.0;
                }
            }

            // Process any completed orders for metrics
            processCompletions();

            // Update drone positions and animations
            updateDronePositions();

            // Update metrics UI periodically (not every frame for performance)
            if (Math.floor(sim.simT * 4) > Math.floor((sim.simT - dtReal * params.timeScale) * 4)) {
                // Update roughly every 250ms of sim time
                updateMetricsUI();

                // Log system status periodically
                const queueSize = orders.length - numCompleted;
                if (Math.floor(sim.simT / 60) > Math.floor((sim.simT - dtReal * params.timeScale) / 60)) {
                    // Log every sim-minute
                    const utilization = drones.filter(d => d.active !== null || d.queue.length > 0).length / drones.length;
                    console.log(`[${formatTime(sim.simT)}] Queue: ${queueSize} | Completed: ${numCompleted} | Fleet Utilization: ${(utilization * 100).toFixed(1)}%`);

                    if (queueSize > drones.length * 2) {
                        console.warn(`⚠️ System overloaded! Queue size (${queueSize}) >> Fleet size (${drones.length})`);
                    }
                }
            }

            // Continue animation loop
            requestAnimationFrame(animate);
        }

        console.log('Animation loop initialized');
        console.log('Simulation initialized and ready');

        // =============================================================================
        // Demo Preset
        // =============================================================================

        /**
         * Load demo preset with good default values
         */
        function loadDemoPreset() {
            // Set demo values
            radiusSlider.value = 2.0;
            radiusValue.textContent = '2.0 km';

            buildingsRadiusSlider.value = 3.0;
            buildingsRadiusValue.textContent = '3.0 km';

            numDronesSlider.value = 10;
            numDronesValue.textContent = '10';

            document.getElementById('speed-input').value = 70;
            document.getElementById('load-time-input').value = 30;
            document.getElementById('service-time-input').value = 30;
            document.getElementById('turnaround-time-input').value = 60;

            ordersPerHourSlider.value = 60;
            ordersPerHourValue.textContent = '60';

            timeScaleSlider.value = 1.0;
            timeScaleValue.textContent = '1.0x';

            console.log('Demo preset loaded');

            // Optionally reset simulation with new params
            reset();
        }

        // Wire up demo preset button
        const demoPresetBtn = document.getElementById('demo-preset-btn');
        demoPresetBtn.addEventListener('click', loadDemoPreset);

        // Wire up load districts button
        const loadDistrictsBtn = document.getElementById('load-districts-btn');
        if (loadDistrictsBtn) {
            console.log('Load districts button found');
            loadDistrictsBtn.addEventListener('click', async () => {
                console.log('Load districts button clicked');
                loadDistrictsBtn.disabled = true;
                loadDistrictsBtn.textContent = 'Loading districts...';
                try {
                    await fetchSpecificDistricts();
                    loadDistrictsBtn.textContent = '✓ Districts Loaded';
                    loadDistrictsBtn.style.background = '#28a745';
                } catch (error) {
                    console.error('Failed to load districts:', error);
                    alert('Error loading districts: ' + error.message);
                    loadDistrictsBtn.textContent = 'Error - Try Again';
                    loadDistrictsBtn.disabled = false;
                }
            });
        } else {
            console.error('Load districts button NOT found!');
        }
    </script>
</body>
</html>
